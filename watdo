#!/bin/bash
# tweet while u hack

# Please report bugs here: https://github.com/arthurdent/watdo

# Dependencies: curl, perl, cut, openssl, base64

[[ -e "$HOME/.config/watdo" ]] && source "$HOME/.config/watdo"

# Final variables
watdo_version="Watdo 0.1.1a"
oauth_signature_method="HMAC-SHA1"
oauth_version="1.0"

# Variables with forced global scope
oauth_nonce=""
oauth_timestamp=""
wrap=""

# Here it is. OAuth can bite me. What a seriously dumb implementation. 
# Protip: twitter will give you like infinity of these damn things for
# free so if you want to spam or something then get your own.
# If you use this one to spam, it will ban this key from legitimate use,
# making my users sad and confused.
# User: If you find yourself sad and confused, consider generating your own
# OAuth Consumer Key & Secret by applying to http://dev.twitter.com
# You will then need to reauthorize watdo
oauth_consumer_key="f0SI6q2G4qFnEDS1o5kjGw"
oauth_consumer_secret="PkWaVAkqzlbE2bbIfkl8Zbmyh6alvwekF77snqgZI"

# do the thing
main() {

	# App will attempt to authorize if this file is missing.
	if [[ ! -e "$HOME/.config/watdo" ]]; then
		echo -e "You will now need to authorize watdo to tweet from your computer.\n"
		authorize
	fi

	# Flags
	while :
	do
		case $1 in
			-A | --authorize) # Gotta do this to post with watdo
				authorize
				exit 0
				;;
			-w | --wrap) # Multiple tweets if > 140 chars
				wrap="true"
				shift
				;;
			-n | --no-wrap) # Cut off tweet after 140 chars
				wrap="false"
				shift
				;;
			-V | --version) # Check the version
				echo "$watdo_version"
				exit 0
				;;
			-h | --help | -\?) # Help info
				watdo_help
				exit 0
				;;
			-*) # Unknown flag
				echo "Unknown option: \"$1\"" >&2
				exit 1
				;;
			*) # The tweet
				if read -t0; then
					read -r stdin_tweet
					status_update "$stdin_tweet"
				elif [[ -n "$@" ]]; then
					status_update "$@"
				else
					watdo_help
				fi
				exit 0
				;;
		esac
	done

}

watdo_help() {
	echo "Usage: $0 [OPTION]... [TWEET]"
	echo "Tweet while you hack."
	echo ""
	echo " -A, --authorize       force app/account reauthorization"
	echo ""
	echo " -w, --wrap            automatically split tweets over 140 characters"
	echo " -n, --no-wrap         cut off tweet at 140 characters"
	echo ""
	echo " -V, --version         display the version and exit"
	echo " -h, --help            display this help output and exit"
	echo ""
	echo "$watdo_version is released under GPLv3"
	echo "Report bugs on Github: https://github.com/arthurdent/watdo"
}

# Refresh the nonce and timestamp
oauth_refresh() {
	
	# Refresh the nonce
	oauth_nonce="$(md5sum <<< \"$RANDOM-$(date +%s.%N)\" | cut -d' ' -f 1)"
	
	# Refresh the timestamp
	oauth_timestamp="$(date +%s)"

}

# Convert non :alphanum: with hex values preceded by % (like URLs)
# I wonder how hard it would be to do this using only bash built-ins.
pe() {
	echo -n "$@" | perl -p -e 's/([^A-Za-z0-9-._~])/sprintf("%%%02X", ord($1))/seg'
}

# Put stuff on The Twitter
status_update() {

	# The status you typed after ./watdo. May not be relevant in all cases
	update_status="$@"
	
	

	# The 1.1 OAuth API URL to send statuses as POST data
	base_url="https://api.twitter.com/1.1/statuses/update.json"

	# The rest of this function involved a lot of head scratching, 
	# yelling at documentation, acetylsalicylic acid and caffiene ingestion.

	# In an attempt to save you from the same fate,
	# I have attempted a detailed explanation of OAuth

	# Step 1 & 2.
	# Refresh the timestamp, and the nonce.
	# The nonce must be different every time you make a connection through OAuth.
	# The easiest way to make a nonce is to append a random string to the date,
	# and hash the result with md5. A simple feature to prevent replay attacks.
	# The timestamp must be in unix epoch format. (date +%s)
	oauth_refresh

	# Step 3
	# The parameter string is all of the parameters that make up your OAuth Signature. 
	# you must supply this without quotes, separated by ampersands (&), alphabetical order.
	# The parameters are those required to make the OAuth request, minus the signature itself.
	parameterstring="oauth_consumer_key=$oauth_consumer_key&oauth_nonce=$oauth_nonce&oauth_signature_method=$oauth_signature_method&oauth_timestamp=$oauth_timestamp&oauth_token=$oauth_token&oauth_version=$oauth_version&status=$(pe $update_status)"

	# Step 4
	# The base string is POST&<URL>&<perameter string>
	# The URL and parameter string must be URL encoded
	# (replace non [[:alphanum:]] with %encoded value
	basestring="POST&$(pe $base_url)&$(pe $parameterstring)"

	# Step 5
	# The signing key is the apps (not users) consumer secret,
	# and the OAuth token secret, which does belong to the user.
	signingkey="$(pe $oauth_consumer_secret)&$(pe $oauth_token_secret)"

	# Step 6: 
	# Now sha1 the base string using the signing key and base64 the result.
	oauth_signature="$(echo -n "$basestring" | openssl dgst -sha1 -binary -hmac "$signingkey" | base64)"

	# Step 7: Authorization header
	# Now you must create an authorization header. This is NOT POST data.
	# This header must start with "Authorization: OAuth", and cant have newlines.
	# Follow with comma separated keys, quote encapsulated values, alphabetical order.
	# The required key/value for any request can be found here: 
	# http://oauth.net/core/1.0/#anchor9
	# Be sure to include the signature in this part of the request.
	auth_header="Authorization: OAuth oauth_consumer_key=\"$oauth_consumer_key\", oauth_nonce=\"$oauth_nonce\", oauth_signature=\"$(pe $oauth_signature)\", oauth_signature_method=\"$oauth_signature_method\", oauth_timestamp=\"$oauth_timestamp\", oauth_token=\"$oauth_token\", oauth_version=\"$oauth_version\""

	# Step 8: Pray.
	# Pray that you did every single one of those things correctly,
	# because chances are, if you made a single mistake, you probably made five.

	# Debug output. Display your shortcomings for all to see.
	#verbose_output

	# Step 9: Mail off your masterpiece.
	curl -s -H "$auth_header" --data-urlencode "status=$update_status" "$base_url" > /dev/null
	echo "Tweet posted: $update_status"

}

# Authorize watdo so you can use it to tweet.
authorize() {

	if [[ ! -e "$HOME/.config/watdo" ]] || [[ "$noconf" == "true" ]] ; then
		request_request_token
	else
		echo "Please move or delete \"$HOME/.config/watdo\" if you really want to reauthorize this application."
	fi

}

# Request a request token. This is the first step in tweeting from watdo.
request_request_token() {

	# This is the quote that accurately somes up this project:
	# When I wrote this, only God and I understood what I was doing. 
	# Now, only God knows.
	# - Karl Weierstrass

	oauth_refresh
	
	# The 1.1 OAuth API URL for requesting request tokens
	base_url="https://api.twitter.com/oauth/request_token"
	
	# This is the proper callback to use when writing desktop applications with OAuth.
	# Incedentally, there is no proper way to write a desktop application with OAuth.
	oauth_callback="oob"

	parameterstring="oauth_callback=$oauth_callback&oauth_consumer_key=$oauth_consumer_key&oauth_nonce=$oauth_nonce&oauth_signature_method=$oauth_signature_method&oauth_timestamp=$oauth_timestamp&oauth_version=$oauth_version"
	basestring="POST&$(pe $base_url)&$(pe $parameterstring)"

	# User doesnt have a token yet, but still needs a trailing "&"
	signingkey="$(pe $oauth_consumer_secret)&" 
	oauth_signature="$(echo -n "$basestring" | openssl dgst -sha1 -binary -hmac "$signingkey" | base64)"

	auth_header="Authorization: OAuth oauth_callback=\"$oauth_callback\", oauth_consumer_key=\"$oauth_consumer_key\", oauth_nonce=\"$oauth_nonce\", oauth_signature=\"$(pe $oauth_signature)\", oauth_signature_method=\"$oauth_signature_method\", oauth_timestamp=\"$oauth_timestamp\", oauth_version=\"$oauth_version\""

	# Uncomment for debugging.
	#verbose_output

	tokens=$(curl -s -H "$auth_header" --data-urlencode ''  "$base_url")

	oauth_request_token=$(cut -d'&' -f1 <<< "$tokens")
	oauth_request_token_secret=$(cut -d'&' -f2 <<< "$tokens")
	
	echo "Go here to get your pin : https://api.twitter.com/oauth/authorize?$oauth_request_token"
	echo -n "PIN : "
	read pin

	request_access_token "$pin" "${oauth_request_token#*=}" "${oauth_request_token_secret#*=}"

}

# Exchange the OAuth Request Token we just requested for an OAuth Access Token
request_access_token() {
	
	oauth_refresh
	base_url="https://api.twitter.com/oauth/access_token"

	oauth_verifier="$1"
	oauth_token="$2"
	oauth_request_token_secret="$3"

	parameterstring="oauth_consumer_key=$oauth_consumer_key&oauth_nonce=$oauth_nonce&oauth_signature_method=$oauth_signature_method&oauth_timestamp=$oauth_timestamp&oauth_token=$oauth_token&oauth_verifier=$oauth_verifier&oauth_version=$oauth_version"
	basestring="POST&$(pe $base_url)&$(pe $parameterstring)"

	# Use the request token secret in place of the user's 
	# token secret, because the user still doesn't have one.
	signingkey="$(pe $oauth_consumer_secret)&$(pe $oauth_request_token_secret)" 
	oauth_signature="$(echo -n "$basestring" | openssl dgst -sha1 -binary -hmac "$signingkey" | base64)"

	auth_header="Authorization: OAuth oauth_consumer_key=\"$oauth_consumer_key\", oauth_nonce=\"$oauth_nonce\", oauth_signature=\"$(pe $oauth_signature)\", oauth_signature_method=\"$oauth_signature_method\", oauth_timestamp=\"$oauth_timestamp\", oauth_token=\"$oauth_token\", oauth_verifier=\"$oauth_verifier\", oauth_version=\"$oauth_version\""

	tokens=$(curl -s -H "$auth_header" --data-urlencode '' "$base_url")

	oauth_access_token=$(cut -d'&' -f1 <<< "$tokens")
	oauth_access_token_secret=$(cut -d'&' -f2 <<< "$tokens")
	oauth_user_id=$(cut -d'&' -f3 <<< "$tokens")
	oauth_screen_name=$(cut -d'&' -f4 <<< "$tokens")

	write_config "${oauth_token#*=}" "${oauth_token_secret#*=}" "${oauth_user_id#*=}" "${oauth_screen_name#*=}"

}

write_config() {

	echo "oauth_token=\"$1\"" > "$HOME/.config/watdo"
	echo "oauth_token_secret=\"$2\"" >> "$HOME/.config/watdo"
	echo "oauth_user_id=\"$3\"" >> "$HOME/.config/watdo"
	echo "oauth_screen_name=\"$4\"" >> "$HOME/.config/watdo"

}

# This provides verbose output (also increments i by 1).
verbose_output() {
	echo "oauth_consumer_key     : $oauth_consumer_key"
	echo "oauth_nonce            : $oauth_nonce"
	echo "oauth_signature        : $oauth_signature"
	echo "oauth_signature_method : $oauth_signature_method"
	echo "oauth_timestamp        : $oauth_timestamp"
	echo "oauth_token            : $oauth_token"
	echo "oauth_version          : $oauth_version"
	echo "---"
	echo "oauth_token_secret     : $oauth_token_secret"
	echo "status                 : $update_status"
	echo "base_url               : $base_url"
	echo "---"
	echo "paramstring            : $parameterstring"
	echo "basestring             : $basestring"
	echo "signingkey             : $signingkey"
	echo "oauth_sign             : $oauth_signature"
	echo "auth_header            : $auth_header"
	echo ""
}

# do the thing
main "$@"

# TODO:
# * Count tweet length, split if > 140 chars ([S]plit [C]ancel)
# * Parse urls in tweets and count them 20 characters.
# * Retrieve tweets from newsfeed etc.
